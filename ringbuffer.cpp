#include <stdlib.h>#include <string.h>#include <sys/types.h>#include <sys/stat.h>#include <stdio.h>#include <errno.h>#include "ringbuffer.h"int rb_init (RingBuffer_t *rb, int size, int memType){	int real_size;	pthread_mutexattr_t attr;	if (rb==NULL || size <= 1024)	{		return -1;	}	real_size = (size&3) ? (size+4-(size&3)) : size;	switch (memType)	{	case MEM_TYPE_HEAP:		rb->buffer = (char*)malloc(real_size);		break;	}	if (rb->buffer == NULL)	{		printf("Not enough memory\n");		return -1;	}	memset (rb->buffer, 0, real_size);	rb->memType = memType;	rb->rd_pointer = 0;	rb->wr_pointer = 0;	rb->size = real_size;	rb->checksize = (real_size >> 4);	pthread_mutexattr_init(&attr);	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);//PTHREAD_MUTEX_RECURSIVE_NP);	pthread_mutex_init(&rb->lock,&attr);	pthread_mutexattr_destroy(&attr);	return 0;}int rb_deinit(RingBuffer_t *rb){	pthread_mutex_lock(&rb->lock);	if (rb->buffer)	{		switch (rb->memType)		{		case MEM_TYPE_HEAP:			free(rb->buffer);			break;		}		rb->buffer = NULL;	}	rb->rd_pointer = rb->size = rb->wr_pointer = 0;	pthread_mutex_unlock(&rb->lock);	pthread_mutex_destroy(&rb->lock);	return 0;}int rb_write (RingBuffer_t *rb, unsigned char *buf, int len){	int total;	int i;	/* total = len = min(space, len) */	pthread_mutex_lock(&rb->lock);	total = rb_free(rb);	if (len > total)		len = total;	else		total = len;	i = rb->wr_pointer;	if (i + len > rb->size)	{		memcpy(rb->buffer + i, buf, rb->size - i);		buf += rb->size - i;		len -= rb->size - i;		i = 0;	}	memcpy(rb->buffer + i, buf, len);	rb->wr_pointer = i + len;	pthread_mutex_unlock(&rb->lock);	return total;}int rb_free (RingBuffer_t *rb){	return(rb->size - 1 - rb_data_size(rb));}int rb_read (RingBuffer_t *rb, unsigned char * buf, int max){	int total;	int i;	/* total = len = min(used, len) */	pthread_mutex_lock(&rb->lock);	total = rb_data_size(rb);	if (max > total)		max = total;	else		total = max;	i = rb->rd_pointer;	if (i + max > rb->size)	{		memcpy(buf, rb->buffer + i, rb->size - i);		buf += rb->size - i;		max -= rb->size - i;		i = 0;	}	memcpy(buf, rb->buffer + i, max);	rb->rd_pointer = i + max;	pthread_mutex_unlock(&rb->lock);	return total;}int rb_data_size (RingBuffer_t *rb){	int size;	//pthread_mutex_lock(&rb->lock);	size = ((rb->wr_pointer - rb->rd_pointer) & (rb->size-1));	//pthread_mutex_unlock(&rb->lock);	return size;}int rb_clear (RingBuffer_t *rb){	pthread_mutex_lock(&rb->lock);	rb->rd_pointer=0;	rb->wr_pointer=0;	pthread_mutex_unlock(&rb->lock);	return 0;}int rb_seek(RingBuffer_t *rb, int offset){	pthread_mutex_lock(&rb->lock);#if 0	if (offset > rb_data_size(rb) || offset < 0)	{		pthread_mutex_unlock(&rb->lock);		return -1;	}#endif	rb->rd_pointer = offset;	pthread_mutex_unlock(&rb->lock);	return offset;}int rb_check_full(RingBuffer_t *rb){    return rb_free(rb) < rb->checksize;}